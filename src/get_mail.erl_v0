%%% -------------------------------------------------------------------
%%% Author  : uabjle
%%% Description : Simple mail server , main use to send info or alarm from eventhandler
%%%
%%% -------------------------------------------------------------------
-module(get_mail).


%% --------------------------------------------------------------------
%% Include files
%% --------------------------------------------------------------------


%% --------------------------------------------------------------------
%% Macros
%% --------------------------------------------------------------------
-define(TIMEOUT, 50000).
-define(IMAPDELAY, 60000).
%% --------------------------------------------------------------------
%% External exports
-export([get_mail/2]).


%% ====================================================================
%% External functions
%% ====================================================================




%% ====================================================================
%% Server functions
%% ====================================================================

get(UserId,PassWd)->
    %Connect 
    application:start(crypto),
    application:start(public_key),
    application:start(ssl),
    {ok,Socket}=imap_connect(),	    
    recv(Socket),
    send_no_receive(Socket,SeqNum ++" "++ "login " ++ UserId ++ " " ++ PassWd),
    recv(Socket), 

    % Retreive mail
    BoxCmd="SELECT " ++ "INBOX",
    {ok,BoxStr}=get_imap(Socket,1,BoxCmd),
    [BoxResult|TBox]=BoxStr,
    BoxR=[SeqNumAcc,"OK","[READ-WRITE]","INBOX","selected.","(Success)"],
    BoxResult = BoxR,

    SeqNumAcc1=add_seq_num(SeqNumAcc,1),
    SearchCmd="SEARCH " ++ "UNSEEN",
    {ok,SearchStr}=get_imap(Socket,SeqNumAcc1,SearchCmd),
 % io:format("Search ~p~n",[SearchStr]),    
    SearchR=[SeqNumAcc1,"OK","SEARCH","completed","(Success)"],
    [SearchResult|TSearch]=SearchStr,
    SearchResult=SearchR,
    [SearchList|TSearch2]=TSearch,
    Len = calc_len(SearchList),
    if 
	Len > 2 -> 
% io:format("New mail branch ~n"),
	    NewMail = true,
	    Id =get(mailId,SearchList),	    
	    SeqNumAcc2=add_seq_num(SeqNumAcc1,1),    
	    HeaderCmd="FETCH " ++ Id ++ " " ++ "BODY.PEEK[HEADER.FIELDS (DATE FROM SUBJECT)]",
	    {ok,HeaderStr}=get_imap(Socket,SeqNumAcc2,HeaderCmd),   
% io:format("Header ~p~n",[HeaderStr]),   
	    HeaderR=[SeqNumAcc2,"OK","Success"],
	    [HeaderResult|THeader]=HeaderStr,
	    HeaderResult=HeaderR,
	    {Sender,Cmd,Parameters}=extract(THeader),

	    SeqNumAcc3=add_seq_num(SeqNumAcc2,1),    
	    TextCmd="FETCH " ++ Id ++ " " ++ "BODY[text]",
	    {ok,TextStr}=get_imap(Socket,SeqNumAcc3,TextCmd),    
	    TextR=[SeqNumAcc3,"OK","Success"],
	    [TextResult|TText]=TextStr,
	    TextResult=TextR,
	    SeqAcc=add_seq_num(SeqNumAcc3,1);
	Len == 2 ->
	    SeqAcc=add_seq_num(SeqNumAcc1,1),
	    NewMail = false,
	    Sender=null,
	    Cmd=no_cmd,
	    Parameters=""
    end,


    % Disconnect

    Send_R= send(Socket,SeqNum ++" "++ "LOGOUT"),
    CloseR= ssl:close(Socket),


%% --------------------------------------------------------------------
%%% Internal functions
%% -------------------------------------------------------------------

get(mailId,[A,CMD|PAR])->    
    [Id|Rest]=PAR,
    Id.

calc_len([])->
    io:format("Error empty list from FETCH cmd ~n");
calc_len(List)->
    calc_len(List,0).
calc_len([],Len)->
    Len;
calc_len(List,Len)->
    [_H|T]=List,
    Len1 = Len+1,
    calc_len(T,Len1).



send_msg(Socket,Msg)->
    send_no_receive(Socket,Msg). 

send_no_receive(Socket, Data) ->
    ssl:send(Socket, Data ++ "\r\n").

send(Socket, Data) ->
    ssl:send(Socket, Data ++ "\r\n"),
    recv(Socket).

recv(Socket) ->
    case ssl:recv(Socket, 0, ?TIMEOUT) of
	{ok, Return} -> 
						% io:format("~p~n", [Return]),
	    R={ok, Return};
	{error, Reason} -> 
						% io:format("ERROR: ~p~n", [Reason]),
	    R={error, Reason}
    end,
    R.

date_mail()->
    {Y,M,D}=erlang:date(),
    Date = integer_to_list(Y) ++ "-" ++ integer_to_list(M) ++ "-" ++ integer_to_list(D),
    Date.
time_mail()->
    {H,M,S}=erlang:time(),
    Time = integer_to_list(H) ++ "-" ++ integer_to_list(M) ++ "-" ++ integer_to_list(S),
    Time.   

myparser(S)->
    S1=string:tokens(S,"\r\n"),
    S2=myparser(S1,[]), 
    S2.
myparser([],Acc)->
    Acc;
myparser(S,Acc)->
    [H|T]=S,
    Acc1 = [string:tokens(H," ")|Acc],
    myparser(T,Acc1).
seq_num(SeqNum)->
    "a" ++ integer_to_list(SeqNum).

add_seq_num(SeqNum,Int)->
    [N1]=string:tokens(SeqNum,"a"),
    Num=list_to_integer(N1)+Int,
    "a" ++ integer_to_list(Num).    

get_imap(Socket,SeqNum,Cmd)->
    ImapMsg=get_imap(Socket,SeqNum,Cmd,[],retreive),
    {ok,ImapMsg}.

get_imap(Socket,SeqNum,Cmd,Acc,retreive)->
    {ok,ImapMsg}=send(Socket,SeqNum ++ " " ++ Cmd),
%    io:format("ImapMsg ==== ~p~n",[ImapMsg]),
    Z=myparser(ImapMsg),
 %   io:format("ImapMsg parserd ==== ~p~n",[Z]),
    Acc1=lists:append(Z,Acc),
    [Result|T]=Z,
    [SeqNumR|T1]=Result,
    case SeqNumR == SeqNum of
	true->
	    [Ok|T2]=T1,
	    case Ok =="OK" of
		true->
		    R=done;
		false->
		    R=retreive
	    end;
	false->
	    R=retreive
    end,
    get_imap(Socket,SeqNum,Cmd,Acc1,R);
	
get_imap(Socket,SeqNum,Cmd,Acc,done)->		    
    Acc.

extract(THeader)->
    Sender=extract(THeader,"From:"),
    {Cmd,Parameters}=extract(THeader,"Subject:"),
    {Sender,Cmd,Parameters}.


extract([],"From:")->
    {error, invalid_sender_address};
extract([HeaderElement|TailElement],"From:")->
    [H|T]=HeaderElement,
    case H of
	"From:"->
	    [Sender|SenderTail]=string:tokens(lists:last(HeaderElement),"< >"),
	    R=Sender;
	_ ->
	    Sender=extract(TailElement,"From:")
    end,
    Sender;

extract([],"Subject:")->
    {error, invalid_subject_string};
extract([HeaderElement|TailElement],"Subject:")->
    [H|T]=HeaderElement,
    case H of
	"Subject:"->
	    [_,Cmd|Parameters]=HeaderElement;	    
	_ ->
	    {Cmd,Parameters}=extract(TailElement,"Subject:")
    end,
    {Cmd,Parameters}.



imap_connect()->
  {Result, Data} = ssl:connect("imap.gmail.com", 993, [{active, false}], ?TIMEOUT),
    case Result of
	ok->
	    R={ok,Data};
	error->
	   io:format("IMAP anslutning misslyckades ~p~n",[Data]),
	   timer:sleep(?IMAPDELAY),
	    R =imap_connect()
    end,
    R.
